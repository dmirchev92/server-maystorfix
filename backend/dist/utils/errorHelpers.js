"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.asyncHandler = exports.customError = exports.operationFailed = exports.serviceUnavailable = exports.databaseError = exports.internalError = exports.reviewExists = exports.alreadyExists = exports.conflict = exports.conversationNotFound = exports.reviewNotFound = exports.notificationNotFound = exports.providerNotFound = exports.caseNotFound = exports.userNotFound = exports.notFound = exports.invalidFormat = exports.validationError = exports.invalidParameters = exports.missingParameters = exports.badRequest = exports.insufficientPermissions = exports.forbidden = exports.invalidCredentials = exports.invalidToken = exports.unauthorized = void 0;
const types_1 = require("../types");
const errorCodes_1 = require("./errorCodes");
const unauthorized = (message = 'Authentication required') => new types_1.ServiceTextProError(message, errorCodes_1.ErrorCodes.UNAUTHORIZED, 401);
exports.unauthorized = unauthorized;
const invalidToken = (message = 'Invalid or expired token') => new types_1.ServiceTextProError(message, errorCodes_1.ErrorCodes.INVALID_TOKEN, 401);
exports.invalidToken = invalidToken;
const invalidCredentials = (message = 'Invalid credentials') => new types_1.ServiceTextProError(message, errorCodes_1.ErrorCodes.INVALID_CREDENTIALS, 401);
exports.invalidCredentials = invalidCredentials;
const forbidden = (message = 'Access forbidden') => new types_1.ServiceTextProError(message, errorCodes_1.ErrorCodes.FORBIDDEN, 403);
exports.forbidden = forbidden;
const insufficientPermissions = (message = 'Insufficient permissions') => new types_1.ServiceTextProError(message, errorCodes_1.ErrorCodes.INSUFFICIENT_PERMISSIONS, 403);
exports.insufficientPermissions = insufficientPermissions;
const badRequest = (message) => new types_1.ServiceTextProError(message, errorCodes_1.ErrorCodes.BAD_REQUEST, 400);
exports.badRequest = badRequest;
const missingParameters = (params) => new types_1.ServiceTextProError(`Missing required parameters: ${params.join(', ')}`, errorCodes_1.ErrorCodes.MISSING_PARAMETERS, 400);
exports.missingParameters = missingParameters;
const invalidParameters = (message) => new types_1.ServiceTextProError(message, errorCodes_1.ErrorCodes.INVALID_PARAMETERS, 400);
exports.invalidParameters = invalidParameters;
const validationError = (message) => new types_1.ServiceTextProError(message, errorCodes_1.ErrorCodes.VALIDATION_ERROR, 400);
exports.validationError = validationError;
const invalidFormat = (field, expected) => new types_1.ServiceTextProError(`Invalid format for ${field}. Expected: ${expected}`, errorCodes_1.ErrorCodes.INVALID_FORMAT, 400);
exports.invalidFormat = invalidFormat;
const notFound = (resource) => new types_1.ServiceTextProError(`${resource} not found`, errorCodes_1.ErrorCodes.NOT_FOUND, 404);
exports.notFound = notFound;
const userNotFound = (userId) => new types_1.ServiceTextProError(userId ? `User ${userId} not found` : 'User not found', errorCodes_1.ErrorCodes.USER_NOT_FOUND, 404);
exports.userNotFound = userNotFound;
const caseNotFound = (caseId) => new types_1.ServiceTextProError(caseId ? `Case ${caseId} not found` : 'Case not found', errorCodes_1.ErrorCodes.CASE_NOT_FOUND, 404);
exports.caseNotFound = caseNotFound;
const providerNotFound = (providerId) => new types_1.ServiceTextProError(providerId ? `Provider ${providerId} not found` : 'Provider not found', errorCodes_1.ErrorCodes.PROVIDER_NOT_FOUND, 404);
exports.providerNotFound = providerNotFound;
const notificationNotFound = (notificationId) => new types_1.ServiceTextProError(notificationId ? `Notification ${notificationId} not found` : 'Notification not found', errorCodes_1.ErrorCodes.NOTIFICATION_NOT_FOUND, 404);
exports.notificationNotFound = notificationNotFound;
const reviewNotFound = (reviewId) => new types_1.ServiceTextProError(reviewId ? `Review ${reviewId} not found` : 'Review not found', errorCodes_1.ErrorCodes.REVIEW_NOT_FOUND, 404);
exports.reviewNotFound = reviewNotFound;
const conversationNotFound = (conversationId) => new types_1.ServiceTextProError(conversationId ? `Conversation ${conversationId} not found` : 'Conversation not found', errorCodes_1.ErrorCodes.CONVERSATION_NOT_FOUND, 404);
exports.conversationNotFound = conversationNotFound;
const conflict = (message) => new types_1.ServiceTextProError(message, errorCodes_1.ErrorCodes.CONFLICT, 409);
exports.conflict = conflict;
const alreadyExists = (resource) => new types_1.ServiceTextProError(`${resource} already exists`, errorCodes_1.ErrorCodes.ALREADY_EXISTS, 409);
exports.alreadyExists = alreadyExists;
const reviewExists = (caseId) => new types_1.ServiceTextProError(`Review for case ${caseId} already exists`, errorCodes_1.ErrorCodes.REVIEW_EXISTS, 409);
exports.reviewExists = reviewExists;
const internalError = (message = 'Internal server error') => new types_1.ServiceTextProError(message, errorCodes_1.ErrorCodes.INTERNAL_ERROR, 500);
exports.internalError = internalError;
const databaseError = (message = 'Database operation failed') => new types_1.ServiceTextProError(message, errorCodes_1.ErrorCodes.DATABASE_ERROR, 500);
exports.databaseError = databaseError;
const serviceUnavailable = (message = 'Service temporarily unavailable') => new types_1.ServiceTextProError(message, errorCodes_1.ErrorCodes.SERVICE_UNAVAILABLE, 503);
exports.serviceUnavailable = serviceUnavailable;
const operationFailed = (operation, reason) => new types_1.ServiceTextProError(reason ? `${operation} failed: ${reason}` : `${operation} failed`, errorCodes_1.ErrorCodes.OPERATION_FAILED, 500);
exports.operationFailed = operationFailed;
const customError = (message, code, statusCode) => new types_1.ServiceTextProError(message, code, statusCode);
exports.customError = customError;
const asyncHandler = (fn) => {
    return (req, res, next) => {
        Promise.resolve(fn(req, res, next)).catch(next);
    };
};
exports.asyncHandler = asyncHandler;
//# sourceMappingURL=errorHelpers.js.map